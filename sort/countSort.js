/**
 * 计数排序
 * 基本原理：根据无序数列的取值范围，新建一个下标值满足该范围的统计数组，元素初始值全为0，然后遍历无序数列，与无序数列元素值相等的统计数组下标对应的元素进行加 1 操作，
 * 该数组中每一个下标位置的值代表数列中对应整数出现的次数，最后直接遍历统计数组，输出数组元素的下标值，元素的值是几，就输出几次
 * 
 * 步骤：
 * 1、以数列最大值-最小值+1作为统计数组的长度，同时，数列的最小值作为一个偏移量，用于计算整数在统计数组中的下标
 * 例：95,94,91,98,99,90,95这个数列，统计数组的长度为99-90+1=10，偏移量为90，对于 第一个整数95，对应的统计数组下标是：95-90=5
 * 2、为了保持数列中相同值的原有顺序，做点修改，从统计数组的第2个元素开始，每一个元素都加上前面所有元素之和。接着从后向前遍历待排序数列，找到与每个元素对应的统计数组的下标对应的值n，
 * n为多少，就代表该元素排在第n位，然后n-1，后续如果再出现相同值的元素，就排在n-1位
 * 例：最后一位是95，95对应的统计数组的下标是5，下标对应的值为5，代表这个95排在第5位，然后5-1=4，接下来如果再出现95，就排在第4位，以此类推。
 * 
 * 缺点：
 * 1、当数列最大和最小值差距过大时，并不适合用计数排序
 * 2、当数列元素不是整数时，也不适合用计数排序
 */


/**
 * @param {*} arr 待排序的数组
 */
function countSort (arr) {
  // 1、得到数组的最大值和最小值，并算出差值
  var max = arr[0]
  var min = arr[0]
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i]
    }
    if (arr[i] < min) {
      min = arr[i]
    }
  }
  var d = max - min
  // 2、创建统计数组，并统计对应元素的个数
  var countArr = new Array(d+1).fill(0)
  for (var i = 0; i < arr.length; i++) {
    countArr[arr[i]-min]++
  }
  // 3、统计数组做变形，后面的元素等于前面的元素之和
  for (var i = 1; i < countArr.length; i++) {
    countArr[i] += countArr[i - 1] 
  }
  // 4、倒序遍历原始数列，从统计数组找到正确位置，输出到结果数组
  var sortArr = new Array(arr.length).fill(0)
  for (var i = arr.length - 1; i >= 0; i--) {
    sortArr[countArr[arr[i] - min] - 1] = arr[i]
    countArr[arr[i] - min]--
  }
  return sortArr
}

var arr = [95,94,91,98,99,90,99,93,91,92]

console.log(countSort(arr))